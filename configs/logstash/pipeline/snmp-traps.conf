input {
  snmptrap {
    host => "0.0.0.0"
    port => 1062
    community => ["public"]
  }
}

filter {
  # Store the trap OID in a simpler field
  if [iso.org.dod.internet.snmpV2.snmpModules.snmpMIB.snmpMIBObjects.snmpTrap.snmpTrapOID.0] {
    mutate {
      copy => { "[iso.org.dod.internet.snmpV2.snmpModules.snmpMIB.snmpMIBObjects.snmpTrap.snmpTrapOID.0]" => "[snmp][trap_oid]" }
    }
  }

  # Extract interface info from message using Ruby
  ruby {
    code => '
      msg = event.get("message").to_s
      
      # Extract interface name (ifDescr - OID 1.3.6.1.2.1.2.2.1.2.X)
      if match = msg.match(/1\.3\.6\.1\.2\.1\.2\.2\.1\.2\.\d+["\s:=]+([^"}\s,]+)/)
        event.set("[interface][name]", match[1].gsub(/["\\]/, ""))
      end
      
      # Extract interface index (ifIndex - OID 1.3.6.1.2.1.2.2.1.1.X)
      if match = msg.match(/1\.3\.6\.1\.2\.1\.2\.2\.1\.1\.(\d+)/)
        event.set("[interface][index]", match[1].to_i)
      end
      
      # Extract oper status (ifOperStatus - OID 1.3.6.1.2.1.2.2.1.8.X) - 1=up, 2=down
      if match = msg.match(/1\.3\.6\.1\.2\.1\.2\.2\.1\.8\.\d+["\s:=]+(\d+)/)
        status = match[1].to_i
        event.set("[interface][oper_status]", status)
        event.set("[interface][oper_status_text]", status == 1 ? "up" : "down")
      end
    '
  }

  # Map source IP to router name
  ruby {
    code => '
      host = event.get("host")
      ip = host.is_a?(Hash) ? host["ip"] : host.to_s
      event.set("[host][ip]", ip)
      
      router_map = {
        "172.20.20.23" => "csr23",
        "172.20.20.24" => "csr24", 
        "172.20.20.25" => "csr25",
        "172.20.20.26" => "csr26",
        "172.20.20.27" => "csr27",
        "172.20.20.28" => "csr28",
        "172.20.20.29" => "csr29"
      }
      event.set("[host][name]", router_map[ip]) if router_map[ip]
    '
  }

  # Identify trap type by OID and set event fields
  if [snmp][trap_oid] == "1.3.6.1.6.3.1.1.5.3" {
    mutate { 
      add_tag => ["linkDown", "alert"]
      add_field => { 
        "[event][action]" => "interface-down"
        "[event][kind]" => "alert"
        "[event][category]" => "network"
        "[event][type]" => "connection"
        "[event][outcome]" => "failure"
      }
    }
  } else if [snmp][trap_oid] == "1.3.6.1.6.3.1.1.5.4" {
    mutate { 
      add_tag => ["linkUp"]
      add_field => { 
        "[event][action]" => "interface-up"
        "[event][kind]" => "event"
        "[event][category]" => "network"
        "[event][type]" => "connection"
        "[event][outcome]" => "success"
      }
    }
  } else if [snmp][trap_oid] == "1.3.6.1.6.3.1.1.5.1" {
    mutate {
      add_tag => ["coldStart"]
      add_field => {
        "[event][action]" => "cold-start"
        "[event][kind]" => "event"
        "[event][category]" => "host"
      }
    }
  } else if [snmp][trap_oid] =~ /^1\.0\.8802/ {
    mutate {
      add_tag => ["lldp"]
      add_field => {
        "[event][action]" => "lldp-change"
        "[event][kind]" => "event"
        "[event][category]" => "network"
      }
    }
  }

  # CRITICAL: Remove dynamic OID fields that cause mapping conflicts
  ruby {
    code => '
      to_remove = event.to_hash.keys.select { |k| 
        k.start_with?("iso.") || 
        k.start_with?("enterprises.") || 
        k.start_with?("1.3.6.1") ||
        k.start_with?("1.0.8802")
      }
      to_remove.each { |f| event.remove(f) }
    '
  }

  # Clean up
  mutate {
    remove_field => ["@version"]
  }
}

output {
  stdout {
    codec => rubydebug
  }

  elasticsearch {
    hosts => ["https://network-demo-f289e8.es.us-central1.gcp.cloud.es.io:443"]
    api_key => "aEFZNHJwb0I5TXhyMmdZdVBHQmU6Z0E1cElQYlgyeFJtQmQwRzFlcHNlQQ=="
    data_stream => true
    data_stream_type => "logs"
    data_stream_dataset => "snmp.trap"
    data_stream_namespace => "prod"
  }
}
